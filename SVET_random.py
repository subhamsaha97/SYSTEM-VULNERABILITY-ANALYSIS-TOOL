import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import random

import time
start_time = time.time()
node_number =50
#min_height=int(node_number/100)
min_height=3
max_height=5
min_rank=2
max_rank=5
#max_height=int(node_number/70 )
#min_rank=int(node_number/100)
#max_rank=int(node_number/50)
edges=2*node_number
initial_nodes=2
percent = 40

G=nx.barabasi_albert_graph(node_number,initial_nodes)
G=nx.gnm_random_graph(node_number,2*node_number,directed=True)
pos=nx.random_layout(G)
nx.draw(G,pos,with_labels=True,node_size=100,edge_color='b')
nx.draw(G,pos)

plt.show()

exploit_nodes = []
for i in range(node_number):
	exploit_nodes.append(i) 
exploit_dict={}

G=nx.DiGraph()
for i in range(node_number):
	G.add_node(i)
while(edges>0):
	a=random.randint(0,node_number-1)
	b=a
	while b==a:
		b=random.randint(0,node_number-1)
	if G.has_edge(a,b):
		continue;
	G.add_edge(a,b)
	if(nx.is_directed_acyclic_graph(G)):
		edges-=1
		if a in exploit_dict:
			exploit_dict[a].append(b)
		else:
			exploit_dict[a]=[b]
	else:
		G.remove_edge(a,b)

"""
G=nx.DiGraph()
for i in range(node_number):
	G.add_node(i)
height=random.randint(min_height,max_height);
for i in range(height):
	for j in range(node_number):
		while curr_rank!=0:
			t = random.randint(0,node_number-1)
			if t==j:
				continue
			
			G.add_edge(j,t)
			if(nx.is_directed_acyclic_graph(G)):
				if j in exploit_dict:
					exploit_dict[j].append(t)
				else:
					exploit_dict[j]=[t]
			else:
				G.remove_edge(j,t)
				continue
			curr_rank-=1

"""

#G=random_dag(node_number,3*node_number)
print("actual graph")
#print(exploit_dict)
exploit_nodes.sort()
pos=nx.random_layout(G)
nx.draw(G,pos,with_labels=True,node_size=200,edge_color='b')
plt.show()
t1=time.time() - start_time
print("------graphtime:: %s seconds ---" % (t1))
mid_time = time.time()

starting_nodes=[]
for i in exploit_nodes:
    flag = 0
    for val in exploit_dict.values():
        if i in val:
            flag=1
            break
    if flag == 0:
        starting_nodes.append(i)
print("starting_nodes:")
print(starting_nodes)



#******************

def simple_cycles(G):
    # Yield every elementary cycle in python graph G exactly once
    # Expects a dictionary mapping from vertices to iterables of vertices
    def _unblock(thisnode, blocked, B):
        stack = set([thisnode])
        while stack:
            node = stack.pop()
            if node in blocked:
                blocked.remove(node)
                stack.update(B[node])
                B[node].clear()
    G = {v: set(nbrs) for (v,nbrs) in G.items()} # make a copy of the graph
    sccs = strongly_connected_components(G)
    while sccs:
        scc = sccs.pop()
        startnode = scc.pop()
        path=[startnode]
        blocked = set()
        closed = set()
        blocked.add(startnode)
        B = defaultdict(set)
        stack = [ (startnode,list(G[startnode])) ]
        while stack:
            thisnode, nbrs = stack[-1]
            if nbrs:
                nextnode = nbrs.pop()
                if nextnode == startnode:
                    yield path[:]
                    closed.update(path)
                elif nextnode not in blocked:
                    path.append(nextnode)
                    stack.append( (nextnode,list(G[nextnode])) )
                    closed.discard(nextnode)
                    blocked.add(nextnode)
                    continue
            if not nbrs:
                if thisnode in closed:
                    _unblock(thisnode,blocked,B)
                else:
                    for nbr in G[thisnode]:
                        if thisnode not in B[nbr]:
                            B[nbr].add(thisnode)
                stack.pop()
                path.pop()
        remove_node(G, startnode)
        H = subgraph(G, set(scc))
        sccs.extend(strongly_connected_components(H))

def strongly_connected_components(graph):
    

    index_counter = [0]
    stack = []
    lowlink = {}
    index = {}
    result = []
    
    def _strong_connect(node):
        index[node] = index_counter[0]
        lowlink[node] = index_counter[0]
        index_counter[0] += 1
        stack.append(node)
    
        successors = graph[node]
        for successor in successors:
            if successor not in index:
                _strong_connect(successor)
                lowlink[node] = min(lowlink[node],lowlink[successor])
            elif successor in stack:
                lowlink[node] = min(lowlink[node],index[successor])

        if lowlink[node] == index[node]:
            connected_component = []

            while True:
                successor = stack.pop()
                connected_component.append(successor)
                if successor == node: break
            result.append(connected_component[:])
    
    for node in graph:
        if node not in index:
            _strong_connect(node)
    
    return result

def remove_node(G, target):
    # Completely remove a node from the graph
    # Expects values of G to be sets
    del G[target]
    for nbrs in G.values():
        nbrs.discard(target)

def subgraph(G, vertices):
    # Get the subgraph of G induced by set vertices
    # Expects values of G to be sets
    return {v: G[v] & vertices for v in vertices}
#############

G_reverse = nx.DiGraph()
reverse_graph ={}
for key in exploit_dict.keys():
    for i in exploit_dict[key]:
        
        G_reverse.add_edge(i,key)
        if i in reverse_graph:
            reverse_graph[i].append(key)
        else:
            reverse_graph[i] = [key]



#print(reverse_graph)
#temp = list(nx.descendants(G_reverse, 9))
#print(temp)
#pos=nx.random_layout(G_reverse)
#nx.draw(G_reverse,pos,with_labels=True,node_size=200,edge_color='b')
#plt.show()
#predecessor_dict ={}
#for i in exploit_nodes:
#    predecessor_dict[i]=list(nx.descendants(G_reverse,i))

#print(predecessor_dict)


def default_metric(val):
    if val%3==0:
        return 0.5
    elif val%3==1:
        return 0.4
    else:
    	return 0.6


metric_list = [None]*node_number;
for i in starting_nodes:
	metric_list[i]=default_metric(i);



def find_metric(node):
	#print(node)
    if node not in reverse_graph.keys():
        return default_metric(node)
    print(node)
    sum = 1
    for i in reverse_graph[node]:
        sum=sum*(1-find_metric(i))
 
    #print(temp_immediate)     
    #sum = 1
    #for i in temp_immediate:
        #sum = sum + 1/find_metric(i)
    #    sum=sum*(1-find_metric(i))
    #sum = 1/sum + default_metric(node)
    sum = (1-sum)*default_metric(node)
    return sum


print("Target Metric:  "+str(find_metric(40))) #CHANGE THE TARGET NODE ACCORDING TO NODE ID

print("------graphtime:: %s seconds ---" % (t1))
print("--- %s seconds ---" % (time.time() - mid_time))
