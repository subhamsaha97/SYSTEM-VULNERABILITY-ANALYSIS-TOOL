import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
file = open("input.txt", mode="r") #INPUT FILE FOR THE SYSTEM
condition_index = []
data = file.read().splitlines()
length = len(data)
for i in range(length):
    temp = data[i].split('::')
    data[i] = temp
    if temp[2] == 'C':
        condition_index.append(i)
print(data)
G = nx.DiGraph()
matrix = np.zeros([length,length], dtype= int)
for i in data:
    if i[3] == 'NIL':
        G.add_node(int(i[0])-1)
    else:
        l = len(i)
        for j in range(3, l):
            for k in range(length):
                if data[k][1] == i[j]:
                    G.add_edge(k, int(i[0])-1)
                    matrix[k][int(i[0])-1] = 1

pos = nx.planar_layout(G)
nx.draw(G, pos, with_labels = True, edge_color = 'b')
plt.show()

#matrix1 = nx.adjacency_matrix(G)
exploit_graph = nx.DiGraph()
#matrix=nx.to_numpy_matrix(G)
#matrix=matrix.tolist()
print("INPUT GRAPH ADJ MATRIX:")
print(matrix)
print(condition_index)
len = len(matrix)
exploit_nodes=[]
exploit_dict = {}
for i in range(len):
    if i not in condition_index:
        for j in range(len):
            if matrix[i][j] == 1.0 and j in condition_index:
                for k in range(len):
                    if matrix[j][k] == 1.0:
                        exploit_graph.add_edge(i, k)
                        if i not in exploit_nodes:
                            exploit_nodes.append(i)
                        if k not in exploit_nodes:
                            exploit_nodes.append(k)
                        if i in exploit_dict:
                            exploit_dict[i].append(k)
                        else:
                            exploit_dict[i] = [k]
            elif matrix[i][j] == 1.0 and j not in condition_index:
                exploit_graph.add_edge(i, j)
                if i not in exploit_nodes:
                    exploit_nodes.append(i)
                if j not in exploit_nodes:
                    exploit_nodes.append(j)
                if i in exploit_dict:
                    exploit_dict[i].append(j)
                else:
                    exploit_dict[i] = [j]
print("actual graph")
print(exploit_dict)
exploit_nodes.sort()
print(exploit_nodes)
cycles = nx.find_cycle(exploit_graph, orientation='original')
print(cycles)
pos = nx.planar_layout(exploit_graph)
nx.draw(exploit_graph, pos, with_labels = True, edge_color = 'b')
plt.show()

# list of starting nodes************************
starting_nodes=[]
for i in exploit_nodes:
    flag = 0
    for val in exploit_dict.values():
        if i in val:
            flag=1
            break
    if flag == 0:
        starting_nodes.append(i)

print(starting_nodes)

# find all the cycles ****************************************************************************************

print("********************THE LIST OF CYCLES PRESENT")

def simple_cycles(G):
    # Yield every elementary cycle in python graph G exactly once
    # Expects a dictionary mapping from vertices to iterables of vertices
    def _unblock(thisnode, blocked, B):
        stack = set([thisnode])
        while stack:
            node = stack.pop()
            if node in blocked:
                blocked.remove(node)
                stack.update(B[node])
                B[node].clear()
    G = {v: set(nbrs) for (v,nbrs) in G.items()} # make a copy of the graph
    sccs = strongly_connected_components(G)
    while sccs:
        scc = sccs.pop()
        startnode = scc.pop()
        path=[startnode]
        blocked = set()
        closed = set()
        blocked.add(startnode)
        B = defaultdict(set)
        stack = [ (startnode,list(G[startnode])) ]
        while stack:
            thisnode, nbrs = stack[-1]
            if nbrs:
                nextnode = nbrs.pop()
                if nextnode == startnode:
                    yield path[:]
                    closed.update(path)
                elif nextnode not in blocked:
                    path.append(nextnode)
                    stack.append( (nextnode,list(G[nextnode])) )
                    closed.discard(nextnode)
                    blocked.add(nextnode)
                    continue
            if not nbrs:
                if thisnode in closed:
                    _unblock(thisnode,blocked,B)
                else:
                    for nbr in G[thisnode]:
                        if thisnode not in B[nbr]:
                            B[nbr].add(thisnode)
                stack.pop()
                path.pop()
        remove_node(G, startnode)
        H = subgraph(G, set(scc))
        sccs.extend(strongly_connected_components(H))

def strongly_connected_components(graph):
    

    index_counter = [0]
    stack = []
    lowlink = {}
    index = {}
    result = []
    
    def _strong_connect(node):
        index[node] = index_counter[0]
        lowlink[node] = index_counter[0]
        index_counter[0] += 1
        stack.append(node)
    
        successors = graph[node]
        for successor in successors:
            if successor not in index:
                _strong_connect(successor)
                lowlink[node] = min(lowlink[node],lowlink[successor])
            elif successor in stack:
                lowlink[node] = min(lowlink[node],index[successor])

        if lowlink[node] == index[node]:
            connected_component = []

            while True:
                successor = stack.pop()
                connected_component.append(successor)
                if successor == node: break
            result.append(connected_component[:])
    
    for node in graph:
        if node not in index:
            _strong_connect(node)
    
    return result

def remove_node(G, target):
    # Completely remove a node from the graph
    # Expects values of G to be sets
    del G[target]
    for nbrs in G.values():
        nbrs.discard(target)

def subgraph(G, vertices):
    # Get the subgraph of G induced by set vertices
    # Expects values of G to be sets
    return {v: G[v] & vertices for v in vertices}


#list_cycles = tuple(simple_cycles(exploit_dict))
#print(list_cycles)
#print(list_cycles[0])


#IMPORTANT*************************************************************

G_reverse = nx.DiGraph()
reverse_graph ={}
for key in exploit_dict.keys():
    for i in exploit_dict[key]:
        
        G_reverse.add_edge(i,key)
        if i in reverse_graph:
            reverse_graph[i].append(key)
        else:
            reverse_graph[i] = [key]

print(reverse_graph)
temp = list(nx.descendants(G_reverse, 9))
print(temp)

predecessor_dict ={}
for i in exploit_nodes:
    predecessor_dict[i]=list(nx.descendants(G_reverse,i))

print(predecessor_dict)

default_metric = {1:2, 3:1, 5:10, 9:2, 11:1, 12:2, 14:1, 16:10, 17:0, 19:0, 21:0, 23:0}


def check_redundancy(node,n,temp_immediate):
    for i in temp_immediate:
        if i in exploit_dict[n]:
            return True
    return False

def find_metric(node):
    if node not in reverse_graph.keys():
        return default_metric[node]
    temp_immediate = []
    for i in reverse_graph[node]:
        if node not in predecessor_dict[i] or i<node:
            temp_immediate.append(i)
    t = []
    for i in temp_immediate:
        for j in exploit_dict[i]:
            if j in temp_immediate:
                t.append(i)
    for i in t:
        temp_immediate.remove(i)
    print(temp_immediate)     
    sum = 0
    for i in temp_immediate:
        sum = sum + 1/find_metric(i)
    sum = 1/sum + default_metric[node]
    return sum

print("Target Metric:  "+str(find_metric(16))) #Give The Target Node ID


